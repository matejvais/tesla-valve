import firedrake as fd
import netgen_mesh as nm # custom module form netgen_mesh.py


def initial_guess(Z, bcs, nu):
    '''
    Copied (with minor modifications) from josef/sudden-expansion/sudden-expansion.py.
    Solve Stokes in velocity-pressure form to make the initial guess.
    '''
    W = fd.MixedFunctionSpace([Z.sub(0), Z.sub(1)])
    z = fd.Function(W)
    w = fd.TestFunction(W)

    Re = 1/nu # Reynolds number

    (u, p) = fd.split(z)
    (v, q) = fd.split(w)
    F = (
            2.0/Re * fd.inner(fd.sym(fd.grad(u)), fd.sym(fd.grad(v)))*fd.dx
        - fd.div(v)*p*fd.dx
        - q*fd.div(u)*fd.dx
        )
    fd.solve(F == 0, z, bcs, solver_parameters={"snes_monitor": None})

    z_ = fd.Function(Z)
    z_.subfunctions[0].assign(z.subfunctions[0])
    z_.subfunctions[1].assign(z.subfunctions[1])

    return z_


def solve_navier_stokes(ngmsh, orientation=1, inlet_velocity_coef=0.1):
    '''
    From nmmo403/lecture5/ns_cylinder.py. Translated from Fenics to Firedrake by Chat GPT with some
    modifications.
    Variables:
        ngmesh - mesh generated by Netgen,
        orientation - 1 for flow from left to right, -1 for flow from right to left,
        inlet_velocity_coef - coefficient that specifies magnitude of velocity on the inlet.
    '''
    mesh = fd.Mesh(ngmsh)

    # Define finite elements
    Ep = fd.FiniteElement("CG", mesh.ufl_cell(), 1)
    Ev = fd.VectorElement("CG", mesh.ufl_cell(), 2)
    Evp = fd.MixedElement([Ev, Ep])

    # Build function spaces (Taylor-Hood)
    W = fd.FunctionSpace(mesh, Evp)

    # define boundary marks for the inlet, the outlet, and the wall
    labels_left = [i+1 for i, name in enumerate(ngmsh.GetRegionNames(codim=1)) if name == "left"]
    labels_right = [i+1 for i, name in enumerate(ngmsh.GetRegionNames(codim=1)) if name == "right"]
    labels_wall = [i+1 for i, name in enumerate(ngmsh.GetRegionNames(codim=1)) if name in ["line","curve"]]

    # define boundary conditions
    (x, y) = fd.SpatialCoordinate(mesh)
    n_curves = len(ngmsh.GetRegionNames(codim=1))   # number of curves forming the boundary of the valve
    z = fd.Function(W)
    if orientation == 1:    # fluid flows from left to right (->)
        print("Flow direction: =>")
        bc_in = fd.DirichletBC(W.sub(0), fd.as_vector([-inlet_velocity_coef*y*(y+38),0]), labels_left)   # inflow velocity profile
        bc_out = fd.DirichletBC(W.sub(0).sub(1), fd.Constant(0), labels_right)  # outflow
        z.subfunctions[0].interpolate(fd.as_vector([-inlet_velocity_coef*y*(y+38), 0]))
    else: # fluid flows from right to left (<-)
        print("Flow direction: <=")
        if n_curves%2 == 1:    # even number of lobes
            bc_in = fd.DirichletBC(W.sub(0), fd.as_vector([inlet_velocity_coef*(y+4)*(y+42),0]), labels_right)   # inflow velocity profile
            z.subfunctions[0].interpolate(fd.as_vector([inlet_velocity_coef*(y+4)*(y+42),0]))
        else:   # odd number of lobes
            bc_in = fd.DirichletBC(W.sub(0), fd.as_vector([inlet_velocity_coef*(y-4)*(y+34),0]), labels_right)
            z.subfunctions[0].interpolate(fd.as_vector([inlet_velocity_coef*(y-4)*(y+34),0]))
        bc_out = fd.DirichletBC(W.sub(0).sub(1), fd.Constant(0), labels_left)  # outflow
    bc_wall = fd.DirichletBC(W.sub(0), 0, labels_wall)    # zero velocity on the walls of the valve
    bcs = [bc_in, bc_wall, bc_out]

    nu = fd.Constant(100) # dynamic viscosity
    dt = 0.05
    t_end = 2
    theta = fd.Constant(0.5)   # Crank-Nicholson timestepping

    # Define unknown and test function(s)
    v_, p_ = fd.TestFunctions(W)

    # current unknown time step
    w = fd.Function(W)
    v, p = fd.split(w)

    # previous known time step
    w0 = fd.Function(W)
    v0, p0 = fd.split(w0)

    def a(v, u):
        D = fd.sym(fd.grad(v))
        return (fd.inner(fd.grad(v)*v, u) + fd.inner(2*nu*D, fd.grad(u)))*fd.dx

    def b(q, v):
        return fd.inner(fd.div(v), q)*fd.dx

    # variational form without time derivative in current time
    F1 = a(v, v_) - b(p_, v) - b(p, v_)

    # variational forms without time derivative in previous time
    F0 = a(v0, v_) - b(p_, v) - b(p, v_)

    # combine variational forms with time derivative
    #
    #  dw/dt + F(w,t) = 0 is approximated as
    #  (w-w0)/dt + theta*F(w,t) + (1-theta)*F(w0,t0) = 0
    #

    F = fd.Constant(1.0/dt)*fd.inner((v-v0), v_)*fd.dx + theta*F1 + (1.0-theta)*F0

    J = fd.derivative(F, w)

    problem = fd.NonlinearVariationalProblem(F, w, bcs=bcs, J=J)
    solver = fd.NonlinearVariationalSolver(problem)

    prm = solver.snes.ksp  # Solver parameters
    # Customize solver parameters (e.g., Newton's method)
    prm.rtol = 1e-12
    prm.atol = 1e-12
    prm.max_it = 20

    # Create files for storing the solution
    lobes = 2+(n_curves-27)/11
    out_file = dict()
    for i in [f'v_lobes={lobes}_orientation={orientation}', f'p_lobes={lobes}_orientation={orientation}']:
        out_file[i] = fd.VTKFile(f"results-navier-stokes/{i}.pvd")

    v, p = w.split()
    v.rename(f"v_lobes={lobes}_orientation={orientation}", "velocity")
    p.rename(f"p_lobes={lobes}_orientation={orientation}", "pressure")

    # Time-stepping
    t = 0.0

    # Calculate the initial guess
    init = initial_guess(W, bcs, nu=nu)
    v_init, p_init = init.subfunctions[0], init.subfunctions[1]

    # Ensure consistency by interpolating the initial guess into the same space
    w_init = fd.Function(W)
    w_init.subfunctions[0].assign(v_init)
    w_init.subfunctions[1].assign(p_init)

    # Write initial conditions
    v, p = w_init.split()
    v.rename(f"v_lobes={lobes}_orientation={orientation}", "velocity")
    p.rename(f"p_lobes={lobes}_orientation={orientation}", "pressure")
    out_file[f'v_lobes={lobes}_orientation={orientation}'].write(v)
    out_file[f'p_lobes={lobes}_orientation={orientation}'].write(p)

    while t < t_end:

        fd.PETSc.Sys.Print("t =", t)

        # move current solution to previous slot w0
        w0.assign(w)

        # update time-dependent parameters
        t += dt

        # Compute
        solver.solve()

        # Extract solutions:
        v, p = w.split()

        # Save to file
        out_file[f'v_lobes={lobes}_orientation={orientation}'].write(v)
        out_file[f'p_lobes={lobes}_orientation={orientation}'].write(p)


if __name__ == "__main__":
    ngmsh = nm.netgen_mesh(lobes=8, max_elem_size=5)
    solve_navier_stokes(ngmsh, orientation=1, inlet_velocity_coef=0.1)